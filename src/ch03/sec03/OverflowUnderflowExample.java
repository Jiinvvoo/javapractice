package ch03.sec03;

public class OverflowUnderflowExample {

	public static void main(String[] args) {
		byte var1 = 125;
		for (int i = 0; i < 5; i++) {	//{ }를 5번 반복
			var1++;						//++ 연산은 var1의 값을 1 증가시킨다.
			System.out.println("var1: " + var1);
		}
// 126 : 0111 1110 | 127 : 0111 1111
// 128 : 1000 0000 = 1000 0000(128부터 부호 비트가 1이므로 -, -128의 2의 보수)
// 129 : 1000 0001 >> 0111 1111(127)의 2의 보수 = -127
// 130 : 1000 0010 >> 0111 1110(126)의 2의 보수 = -126
// => 126 127 -128 -127 -126
		System.out.println("-------------------");
		
		byte var2 = -125;
		for (int i = 0; i < 5; i++) {	//{ }를 5번 반복 실행
			var2--;						//-- 연산은 var2의 값을 1 감소시킨다.
			System.out.println("var2: " + var2);
		}
// -126 -127 -128 까지는 1바이트로 표현 가능.
// -129 : 1000 0001 >> 0111 1111(127)
// -130 : 1000 0010 >> 0111 1110(126)
// => -126 -127 -128 127 126
	}

}
